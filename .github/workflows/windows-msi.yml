# 此工作流用于在 GitHub Actions 的 windows-latest runner 上构建 Windows MSI 安装包。
# - 触发器设置为：当有新的 tag 被 push（例如：git tag v1.2.3 && git push origin v1.2.3）时触发，
#   或者可以在 Actions 页中手动触发（workflow_dispatch）。
# - 整体流程：checkout -> 安装 JDK -> 安装 WiX -> 构建 Maven 包 -> jlink 创建 runtime -> jpackage 打包 MSI -> 上传 artifact
# - 重要：jpackage 在 Windows 上生成 MSI 依赖 WiX 工具集（candle.exe / light.exe），因此会先用 choco 安装 WiX。

name: Build Windows MSI

permissions:
  contents: write

on:
  # 新的 tag push 时触发（例如：git tag v2.1.9 && git push origin v2.1.9）
  push:
    tags: [ '*' ]
  # 手动触发 (Actions 页面 -> Run workflow)
  workflow_dispatch: {}

jobs:
  build-msi:
    name: Build MSI on Windows
    runs-on: windows-latest

    steps:
      - name: Checkout
        # 签出仓库代码
        uses: actions/checkout@v4

      - name: Setup Java 17 (Temurin)
        # 设置 Java 17 环境（jlink 和 jpackage 需要 JDK）
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'maven'

      - name: Install WiX (for jpackage -> MSI)
        shell: pwsh
        run: |
          # 使用 Chocolatey 安装 WiX 工具集（jpackage 生成 MSI 需要）
          choco install wixtoolset -y
          # 确保 PATH 更新在当前 job 中生效（refreshenv）
          if (Get-Command refreshenv -ErrorAction SilentlyContinue) { refreshenv } else {
            $refreshScript = "$env:ChocolateyInstall\lib\refreshenv\tools\RefreshEnv.ps1"
            if (Test-Path $refreshScript) { & $refreshScript } else { Write-Host "refreshenv not found; proceeding anyway" }
          }
          # 验证 WiX 可用性：查找常用可执行文件 candle.exe 与 light.exe
          Write-Host "Looking for WiX executables..."
          Get-Command candle.exe, light.exe -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "Found: $($_.Source)" }
          # 尝试列出可能的安装目录，便于排查
          Get-ChildItem 'C:\Program Files (x86)\WiX*' -Directory -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "WiX dir: $($_.FullName)" }

      - name: Show Java and jpackage info
        shell: pwsh
        run: |
          # 打印 Java 相关信息，确认 Java 与 jpackage 可用
          Write-Host "JAVA_HOME: $env:JAVA_HOME"
          java -version
          $jpackage = Join-Path $env:JAVA_HOME "bin\jpackage.exe"
          if (Test-Path $jpackage) {
            Write-Host "jpackage found at: $jpackage"
            & $jpackage --version
          } else {
            Write-Host "jpackage not found at $jpackage"
          }

      - name: Build with Maven (skip tests)
        shell: pwsh
        run: |
          # 使用 maven 打包（跳过测试以加速 CI），产物会放在 target/ 下
          mvn -B -DskipTests package

      - name: Create MSI with jpackage
        shell: pwsh
        env:
          MAIN_CLASS: com.laker.postman.App
          ICON_PATH: ${{ github.workspace }}\assets\win\EasyPostman.ico
        run: |
          # -----------------------
          # 从 pom.xml 中安全读取项目版本（优先）
          # -----------------------
          $pomPath = Join-Path $PWD 'pom.xml'
          $version = $null
          if (Test-Path $pomPath) {
            try {
              [xml]$pom = Get-Content $pomPath -Raw
              # 处理默认命名空间，使用命名空间管理器进行 XPath 查询
              $nsm = New-Object System.Xml.XmlNamespaceManager($pom.NameTable)
              $nsm.AddNamespace('pom','http://maven.apache.org/POM/4.0.0')
              $node = $pom.SelectSingleNode('/pom:project/pom:version',$nsm)
              if ($node -and $node.'#text') { $version = $node.'#text' } else {
                $node2 = $pom.SelectSingleNode('//pom:version',$nsm)
                if ($node2 -and $node2.'#text') { $version = $node2.'#text' }
              }
            } catch {
              Write-Host "Failed to parse pom.xml with XML parser: $_"
            }
          }
          if (-not $version) {
            # 作为回退，使用 mvn help:evaluate 获取版本（并尝试过滤杂项输出）
            Write-Host "Falling back to 'mvn help:evaluate' to get version"
            $raw = mvn help:evaluate -Dexpression=project.version -DforceStdout 2>&1
            $lines = $raw -split "\r?\n" | Where-Object { $_ -and ($_ -notmatch "^\[|Download|\{.*\}$") }
            $version = $lines[-1].Trim()
          }

          Write-Host "Project version: $version"

          # 校验版本字符串是否合理（避免把整个 pom 内容误用为版本）
          if (-not ($version -and ($version -match '^[0-9]+(\.[0-9]+)*([-+].*)?$'))) {
            Write-Host "ERROR: extracted project version looks invalid: '$version'"
            Write-Host "Printing first 1000 characters of pom.xml for debugging:"
            if (Test-Path $pomPath) {
              $content = Get-Content $pomPath -Raw
              Write-Host $content.Substring(0, [Math]::Min(1000, $content.Length))
            }
            throw "Invalid project version extracted; aborting to avoid creating files with bad names."
          }

          # -----------------------
          # 准备主 jar 和 runtime
          # -----------------------
          # 在 target/ 下寻找生成的 jar（忽略 original-*）
          $jarFile = Get-ChildItem -Path "$PWD\target" -Filter "*.jar" | Where-Object { $_.Name -notlike "original-*" } | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $jarFile) { throw "No jar found in target/" }
          Write-Host "Found jar in target: $($jarFile.Name)"

          # 按照原来的 win.bat 期望的名字：easy-postman-<version>.jar
          $expectedJarName = "easy-postman-$version.jar"
          Write-Host "Expected jar name: $expectedJarName"

          # 确保输出目录存在
          $outDir = "$PWD\dist"
          if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir | Out-Null }

          # -----------------------
          # 使用 jlink 创建 runtime（与 win.bat 保持一致的模块集合），生成 target/runtime
          # -----------------------
          $runtimeDir = "$PWD\target\runtime"
          if (Test-Path $runtimeDir) { Remove-Item -Recurse -Force $runtimeDir }
          $jlink = Join-Path $env:JAVA_HOME "bin\jlink.exe"
          if (-not (Test-Path $jlink)) { throw "jlink not found at $jlink; ensure Java 17 with jlink is installed." }

          $jlinkArgs = @(
            '--add-modules', 'java.base,java.desktop,java.logging,jdk.unsupported,java.naming,java.net.http,java.prefs,java.sql,java.security.sasl,java.security.jgss,jdk.crypto.ec,java.management,java.management.rmi,jdk.crypto.cryptoki',
            '--strip-debug',
            '--no-header-files',
            '--no-man-pages',
            '--compress', '2',
            '--output', $runtimeDir
          )
          Write-Host "Running jlink: $jlink $($jlinkArgs -join ' ')"
          & $jlink @jlinkArgs
          if ($LASTEXITCODE -ne 0) { throw "jlink failed with exit code $LASTEXITCODE" }

          # -----------------------
          # 准备 dist-input（将主 jar 复制到 target/dist-input，并重命名为期望的文件名）
          # -----------------------
          $distInputDir = "$PWD\target\dist-input"
          if (Test-Path $distInputDir) { Remove-Item -Recurse -Force $distInputDir }
          New-Item -ItemType Directory -Path $distInputDir | Out-Null

          $sourceExpected = Join-Path "$PWD\target" $expectedJarName
          if (Test-Path $sourceExpected) {
            Copy-Item $sourceExpected -Destination $distInputDir
            $mainJarName = $expectedJarName
          } else {
            # fallback: 使用找到的 jar 并拷贝为期望名字
            Copy-Item $jarFile.FullName -Destination (Join-Path $distInputDir $expectedJarName)
            $mainJarName = $expectedJarName
          }
          Write-Host "Copied main jar to dist-input as: $mainJarName"

          # -----------------------
          # 使用 jpackage 生成 MSI（参数和 win.bat 保持一致）
          # 说明：--runtime-image 指向 jlink 生成的 runtime，--dest 是目标目录
          # 常见可调整项：--win-upgrade-uuid（升级识别码）、--vendor、--win-menu-group 等
          # -----------------------
          $jpackage = Join-Path $env:JAVA_HOME "bin\jpackage.exe"
          if (-not (Test-Path $jpackage)) { throw "jpackage not found at $jpackage; ensure Java 17 with jpackage is installed." }

          $args = @(
            '--type', 'msi',
            '--verbose',
            '--input', $distInputDir,
            '--main-jar', $mainJarName,
            '--main-class', $env:MAIN_CLASS,
            '--runtime-image', $runtimeDir,
            '--dest', $outDir,
            '--icon', "$env:ICON_PATH",
            '--name', 'EasyPostman',
            '--app-version', $version,
            '--vendor', 'Laker',
            '--copyright', '© 2025 Laker',
            '--win-shortcut',
            '--win-menu',
            '--win-upgrade-uuid', '28607609-97b7-4212-9285-04ef64a4946c',
            '--win-dir-chooser',
            '--win-per-user-install',
            '--win-menu-group', 'EasyTools',
            '--win-help-url', 'https://gitee.com/lakernote/easy-postman',
            '--java-options', '-Xms256m',
            '--java-options', '-Xmx512m',
            '--java-options', '-Dfile.encoding=UTF-8',
            '--java-options', '-Djavax.accessibility.assistive_technologies='
          )

          Write-Host "Running jpackage: $jpackage $($args -join ' ')"
          & $jpackage @args

      - name: Verify dist contains MSI
        shell: pwsh
        run: |
          # 列出 dist 目录并确认是否生成了 .msi 文件，若无则让步骤失败并打印目录信息用于排查
          $outDir = "$PWD\dist"
          Write-Host "Listing dist directory: $outDir"
          if (Test-Path $outDir) {
            Get-ChildItem -Path $outDir | ForEach-Object { Write-Host $_.FullName $_.Length }
          } else {
            Write-Host "dist directory does not exist"
          }
          $msi = Get-ChildItem -Path $outDir -Filter "*.msi" -ErrorAction SilentlyContinue
          if (-not $msi) { throw "No MSI found in $outDir - jpackage likely failed or produced a file in a different location." }

      - name: Upload MSI artifact
        # 上传生成的 MSI 到 Actions artifact，便于在运行完成后下载
        uses: actions/upload-artifact@v4
        with:
          name: easy-postman-msi
          path: dist/*.msi

      - name: Detect MSI file
        id: detect_msi
        # 在 Windows runner 上用 PowerShell 查找 dist 目录下最新的 .msi，并把路径与文件名导出为步骤输出
        shell: pwsh
        run: |
          $outDir = "$PWD\dist"
          Write-Host "Detecting MSI in: $outDir"
          $msi = Get-ChildItem -Path $outDir -Filter "*.msi" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $msi) { Write-Host "No MSI found in $outDir"; exit 1 }
          Write-Host "Found MSI: $($msi.FullName)"
          # 设置输出供后续步骤使用（GITHUB_OUTPUT 机制）
          "msi_name=$($msi.Name)" | Out-File -Encoding utf8 -FilePath $env:GITHUB_OUTPUT -Append
          "msi_path=$($msi.FullName)" | Out-File -Encoding utf8 -FilePath $env:GITHUB_OUTPUT -Append

      - name: Create GitHub Release (only for tag events)
        # 仅在由 tag 触发的运行中才创建 Release；手动或其它触发不会执行这一步
        if: startsWith(github.ref, 'refs/tags/')
        uses: actions/create-release@v1
        id: create_release
        with:
          tag_name: ${{ github.ref_name }}
          release_name: ${{ github.ref_name }}
          body: "自动生成的 Release：${{ github.ref_name }}（由 CI 构建）"
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload MSI to GitHub Release
        # 将检测到的 MSI 上传为 Release 的资产；仅在 tag 触发时运行
        if: startsWith(github.ref, 'refs/tags/')
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.detect_msi.outputs.msi_path }}
          asset_name: ${{ steps.detect_msi.outputs.msi_name }}
          asset_content_type: application/x-msi

